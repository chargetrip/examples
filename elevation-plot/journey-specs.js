import { getRoutePath } from './queries.js';

/**
 * Show route path specific information like elevation, consumption, speed etc.
 *
 * @param path {object} route path specification.
 */
export const displaySpecs = path => {
  // The consumption, in kWh, of this route path segment.
  document.getElementById('consumption').innerHTML = path.routePath.consumptionPerKm * 1000 + 'Wh/km';
  // The elevation (altitude) in meters for this route path segment.
  document.getElementById('height').innerHTML = path.routePath.elevation + 'm';
  // The average speed, in km/h, for this route path segment.
  document.getElementById('average-speed').innerHTML = path.routePath.avSpeed + 'km';
};

/**
 * Find the closest point in the polyline, to were the user has clicked on the map.
 * @param polyline {object} polyline coordinates.
 * @param location {object} the location that was clicked on the polyline.
 */
export const findClosest = (polyline, location) => {
  const x1 = location[0];
  const y1 = location[1];
  let closest = Math.sqrt(Math.pow(Math.abs(x1 - polyline[0][0]), 2) + Math.pow(Math.abs(y1 - polyline[0][1]), 2));
  let closestIndex = 0;
  let i;
  for (i = 1; i < polyline.length - 1; i++) {
    let distance = Math.sqrt(Math.pow(Math.abs(x1 - polyline[i][0]), 2) + Math.pow(Math.abs(y1 - polyline[i][1]), 2));
    if (distance <= closest) {
      closest = distance;
      closestIndex = i;
    }
  }
  return closestIndex;
};

const markElevationPlot = (closestIndex, coordinates) => {
  const total = coordinates.length;
  const position = (closestIndex * 99) / total / 100;
  document.getElementById('line').style.marginLeft = position * 358 + 'px'; //magic number
};

/**
 * Update route path specific information by clicking on the polyline.
 * @param client {}
 * @param map {object} the map generated by mapbox.
 * @param coordinates object} polyline coordinates.
 * @param id {string} the ID of the route.
 */
export const updateSpecs = (client, map, coordinates, id) => {
  let location = coordinates[0];
  map.on('click', 'polyline', e => {
    location = [e.lngLat.lng, e.lngLat.lat];
    let closest = 0;
    closest = findClosest(coordinates, location);
    markElevationPlot(closest, coordinates);
    while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
      coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
    }
    client
      .query(getRoutePath(id, coordinates[closest]))
      .toPromise()
      .then(response => {
        displaySpecs(response.data);
      })
      .catch(error => console.log(error));
  });
  map.on('mouseenter', 'polyline', () => {
    map.getCanvas().style.cursor = 'pointer';
  });
  map.on('mouseleave', 'polyline', () => {
    map.getCanvas().style.cursor = '';
  });
};
